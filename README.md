три основополагающие идеи пользовательского интерфейса:

Виджеты — отдельные визуальные элементы интерфейса.
Взаимодействия — действия, которые могут быть вызваны какими-либо виджетами.
Состояние — базовое условие или информация интерфейса.

Виджеты создают взаимодействия, когда пользователь взаимодействует с ними. Эти взаимодействия затем изменяют состояние интерфейса. Измененное состояние распространяется и диктует новые виджеты, которые должны быть отображены. Эти новые виджеты могут затем создавать новые взаимодействия, которые могут снова изменить состояние... И так далее.

<div align="center">
  <img alt="The GUI trinity" src="resources/the-gui-trinity.svg">
</div>

Таким образом, создание пользователя интерфейс неизбежно должен состоять в определении этих виджетов, взаимодействий и состояния; а также подключения между ними.

при использовании iced мы будем иметь дело с четырьмя основными понятиями: state (состояние), messages (сообщения), update logic (логика обновления) и view logic (логика просмотра).

Пример кода (пока без графических элементов):

// состояние
struct Counter {
    value: i64,
}

// сообщения
enum Message {
    Increment,
    Decrement,
}

// логика обновления
impl Counter {
    fn update(&mut self, message: Message) {
        match message {
            Message::Increment => {
                self.value += 1;
            }
            Message::Decrement => {
                self.value -= 1;
            }
        }
    }
}

fn main() {
    let mut counter = Counter { value: 0 };
    counter.update(Message::Increment);
    counter.update(Message::Increment);
    counter.update(Message::Decrement);
    println!("{}", counter.value);  // 1
}

Осталось определить логику представления — то, как состояние влияет на виджеты.

Добавим кнопки:
use iced::widget::button;

let increment = button("+");
let decrement = button("-");

и текстовые поля:
use iced::widget::text;

let counter = text(15);

Итак, у нас есть две кнопки и текстовое поле. Теперь их надо отобразить в определенном порядке. Существует шесть различных способов их упорядочивания.

В iced компоновка описывается тоже с помощью виджетов. Вертикальное расположение, которое нужно для нашего счетчика, может быть достигнуто с помощью виджета column:

use iced::widget::column;

let interface = column![increment, counter, decrement];

Мы пока что не определили для них никаких взаимодействий. Как наш пользовательский интерфейс должен выдавать сообщения?
